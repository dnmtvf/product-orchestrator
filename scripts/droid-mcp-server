#!/opt/homebrew/bin/bash
# Droid MCP Server Wrapper
# This script wraps droid exec --headless as an MCP server for worker task execution
# Usage: claude mcp add droid-worker -- ./scripts/droid-mcp-server --mcp
#        Or pipe stdin (best-effort: auto-detects non-TTY stdin; may not work with PTY-based MCP hosts)
#
# Environment setup required:
#   export ANTHROPIC_BASE_URL="https://api.minimax.io/anthropic"
#   export ANTHROPIC_AUTH_TOKEN="your-minimax-api-key"
#   export DROID_CONFIG="--model MiniMax-M2.5 --auto high"

# Note: set -e is intentionally NOT used. The MCP server loop must survive
# individual tool call errors without crashing the entire server process.

# Session storage (in-memory associative array; requires Bash 4+)
declare -A SESSIONS

# Generate session ID
generate_session_id() {
    echo "session-$(date +%s)-$RANDOM"
}

# Run droid task and return JSON
run_droid_task() {
    local prompt="$1"
    local repo_path="${2:-.}"
    local model="${3:-MiniMax-M2.5}"
    local auto_level="${4:-high}"

    local session_id
    session_id=$(generate_session_id)

    # Run droid in non-interactive mode with JSON output
    # Redirect stdin from /dev/null to prevent droid from consuming MCP server's stdin
    local output
    output=$(droid exec \
        -m "$model" \
        --auto "$auto_level" \
        -o json \
        --cwd "$repo_path" \
        "$prompt" </dev/null 2>&1) || true

    # Store session result
    SESSIONS["$session_id"]="$output"

    # Parse and format output as JSON
    local changed_files
    local diff_summary
    local commands_run
    local tests_run
    local risks

    # Extract information from droid output (simplified parsing)
    # In production, this would parse the actual JSON from droid
    changed_files=$(echo "$output" | jq -r '.changed_files // []' 2>/dev/null || echo "[]")
    diff_summary=$(echo "$output" | jq -r '.diff_summary // .summary // ""' 2>/dev/null || echo "")
    commands_run=$(echo "$output" | jq -r '.commands_run // []' 2>/dev/null || echo "[]")
    tests_run=$(echo "$output" | jq -r '.tests_run // {}' 2>/dev/null || echo "{}")
    risks=$(echo "$output" | jq -r '.risks // []' 2>/dev/null || echo "[]")

    # Build response JSON (use jq for all string fields to prevent injection)
    jq -n \
        --arg session_id "$session_id" \
        --arg status "completed" \
        --arg diff_summary "$diff_summary" \
        --argjson changed_files "$changed_files" \
        --argjson commands_run "$commands_run" \
        --argjson tests_run "$tests_run" \
        --argjson risks "$risks" \
        --arg full_output "$output" \
        '{session_id: $session_id, status: $status, changed_files: $changed_files, diff_summary: $diff_summary, commands_run: $commands_run, tests_run: $tests_run, risks: $risks, full_output: $full_output}'
}

# Continue a session with additional prompt
continue_session() {
    local session_id="$1"
    local prompt="$2"

    if [[ -z "${SESSIONS[$session_id]+x}" ]]; then
        jq -n --arg id "$session_id" '{"error": ("Session not found: " + $id)}'
        return 0
    fi

    # For continued sessions, append to previous context
    local previous_output="${SESSIONS[$session_id]}"
    local new_prompt="$prompt (Previous context: $previous_output)"

    local output
    output=$(droid exec \
        -m MiniMax-M2.5 \
        --auto high \
        -o json \
        --cwd . \
        "$new_prompt" </dev/null 2>&1) || true

    SESSIONS["$session_id"]="$output"

    echo "$output"
}

# Get session result
get_session_result() {
    local session_id="$1"

    if [[ -z "${SESSIONS[$session_id]+x}" ]]; then
        jq -n --arg id "$session_id" '{"error": ("Session not found: " + $id)}'
        return 0
    fi

    echo "${SESSIONS[$session_id]}"
}

# MCP server main loop (JSON-RPC over stdio)
# Read from fd 3 to prevent droid subprocesses from consuming MCP stdin
mcp_server() {
    exec 3<&0  # duplicate stdin to fd 3
    while read -r line <&3; do
        # Skip empty lines
        [[ -z "$line" ]] && continue

        # Parse JSON-RPC request (simplified)
        local method
        local id

        method=$(echo "$line" | jq -r '.method // empty' 2>/dev/null)
        id=$(echo "$line" | jq -r '.id // empty' 2>/dev/null)

        case "$method" in
            "initialize")
                # protocolVersion: "2025-03-26" — verified against MCP spec as of 2025-03-26.
                # Re-verify at https://spec.modelcontextprotocol.io if Claude Code rejects this handshake.
                cat <<EOF
{"jsonrpc":"2.0","id":$id,"result":{"protocolVersion":"2025-03-26","capabilities":{"tools":{}},"serverInfo":{"name":"droid-worker","version":"1.0.0"}}}
EOF
                ;;
            "tools/list")
                cat <<EOF
{"jsonrpc":"2.0","id":$id,"result":{"tools":[{"name":"droid_run_task","description":"Run a task using Droid CLI with MiniMax-M2.5","inputSchema":{"type":"object","properties":{"prompt":{"type":"string","description":"Task prompt for the worker"},"repo_path":{"type":"string","description":"Repository path (default: .)"},"model":{"type":"string","description":"Model to use (default: MiniMax-M2.5)"},"auto_level":{"type":"string","description":"Autonomy level (default: high)"}},"required":["prompt"]}},{"name":"droid_continue","description":"Continue a session with additional prompt","inputSchema":{"type":"object","properties":{"session_id":{"type":"string"},"prompt":{"type":"string"}},"required":["session_id","prompt"]}},{"name":"droid_get_result","description":"Get the result of a previous session","inputSchema":{"type":"object","properties":{"session_id":{"type":"string"}},"required":["session_id"]}}]}}}
EOF
                ;;
            "tools/call")
                local tool_name
                tool_name=$(echo "$line" | jq -r '.params.name // empty')

                case "$tool_name" in
                    "droid_run_task")
                        local prompt repo_path model auto_level
                        prompt=$(echo "$line" | jq -r '.params.arguments.prompt // ""')
                        repo_path=$(echo "$line" | jq -r '.params.arguments.repo_path // "."')
                        model=$(echo "$line" | jq -r '.params.arguments.model // "MiniMax-M2.5"')
                        auto_level=$(echo "$line" | jq -r '.params.arguments.auto_level // "high"')

                        local result
                        result=$(run_droid_task "$prompt" "$repo_path" "$model" "$auto_level")
                        echo "{\"jsonrpc\":\"2.0\",\"id\":$id,\"result\":{\"content\":[{\"type\":\"text\",\"text\":$(echo "$result" | jq -Rs .)}]}}"
                        ;;
                    "droid_continue")
                        local session_id prompt
                        session_id=$(echo "$line" | jq -r '.params.arguments.session_id // ""')
                        prompt=$(echo "$line" | jq -r '.params.arguments.prompt // ""')

                        local result
                        result=$(continue_session "$session_id" "$prompt")
                        echo "{\"jsonrpc\":\"2.0\",\"id\":$id,\"result\":{\"content\":[{\"type\":\"text\",\"text\":$(echo "$result" | jq -Rs .)}]}}"
                        ;;
                    "droid_get_result")
                        local session_id
                        session_id=$(echo "$line" | jq -r '.params.arguments.session_id // ""')

                        local result
                        result=$(get_session_result "$session_id")
                        echo "{\"jsonrpc\":\"2.0\",\"id\":$id,\"result\":{\"content\":[{\"type\":\"text\",\"text\":$(echo "$result" | jq -Rs .)}]}}"
                        ;;
                    *)
                        jq -n --argjson id "$id" --arg name "$tool_name" \
                            '{"jsonrpc":"2.0","id":$id,"error":{"code":-32601,"message":("Unknown method: " + $name)}}'
                        ;;
                esac
                ;;
            "notifications/initialized")
                # MCP lifecycle notification — no response required, silently ignore
                ;;
            *)
                jq -n --argjson id "$id" \
                    '{"jsonrpc":"2.0","id":$id,"error":{"code":-32600,"message":"Invalid request"}}'
                ;;
        esac
    done
}

# Check if running as MCP server or direct command
# Auto-detect: if stdin is not a TTY (e.g. launched by Claude Code MCP client), default to MCP mode
if [[ "$1" == "--mcp" ]] || [[ ! -t 0 && -z "$1" ]]; then
    mcp_server
else
    # Direct invocation mode
    case "${1:-}" in
        run)
            run_droid_task "$2" "${3:-.}" "${4:-MiniMax-M2.5}" "${5:-high}"
            ;;
        continue)
            continue_session "$2" "$3"
            ;;
        result)
            get_session_result "$2"
            ;;
        *)
            echo "Usage: $0 <run|continue|result> [args...]"
            echo "       $0 --mcp  # Run as MCP server"
            exit 1
            ;;
    esac
fi
